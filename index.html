<!doctype html>

<html lang="en">

<head>
  <meta charset="utf-8">

  <title>CS373 Weekly Writeups</title>
  <meta name="author" content="Ryder McDowell">

  <link rel="stylesheet" href="./styles.css">
</head>

<body>
  <header>
    Ryder McDowell - CS 373 - Weekly Writeups<br><br>
    (Ordered newest to oldest)
  </header>

  <div class="textContainer">
    <br>
    <h2 class="textHeader">Week 4</h2>
    <p class="textContent">
      &emsp;&emsp;This week’s content is presented by Brad Antoniewicz who works for Intel Security carrying out attacks to provide organizations with vulnerability knowledge on their own system.<br><br>

      &emsp;&emsp;Attacks are carried out through finding vulnerabilities in a system and exploiting them in a way that accomplishing whatever goal the attacker has. This can be by either taking advantage of bugs in a system or by taking advantage of poor programming or configuration. Over the past couple of decades, as the internet has become more integrated into our daily lives and more sensitive information is stored, hacking has gone from something fun and playful to something very dangerous. The good hackers, like Brad, hack ethically, and their goal is to help organizations keep their systems secure by pointing out vulnerabilities that they have found. Some companies, such as Samsung, have “bug bounty” programs that payout individuals who find these vulnerabilities and report them without doing anything harmful.<br><br>
      
      &emsp;&emsp;Some examples of potential vulnerabilities include weak passwords, authorization issues, and inadequate encryption, but this class focused on a form of input validation vulnerability called memory corruption. This means to access memory in an invalid way to get undefined behavior and exploit that behavior into getting some sort of payload or action to be performed. The tool that is demonstrated for aiding in this exploit for Windows machines is WinDbg which allows you to set breakpoints and stop execution of a program in order to explore the memory content and see what is being stored in registers at that point in time. This gives a hacker insight into what, when, and where something needs to be altered in order to have their payload executed.<br><br>
      
      &emsp;&emsp;The lab this week was somewhat of a guided hack to launch the system calculator through a browser exploitation, and WinDbg was a very important tool in doing this. We first began by playing around with different commands in WinDbg to get our fingers comfortable, and after setting a breakpoint and stepping through some commands we were able to find little easter eggs like the string “FluffyBunniesDon’tFlapOrQuack” at the address where esp is pointing and the decimal “31337” being in the eax register using “du poi(esp)” and “.formats eax” commands.<br><br>

      <img src="images/6.png" alt="6" width="500"><br><br>
      <img src="images/7.png" alt="7" width="600"><br><br>

      &emsp;&emsp;After getting warmed up, we began the hack by opening up the javascript and changing one of the function variables to “msfPatternString”, which is a non-repeating string used for exploitation that lets us see where we are at in memory when the program crashes. The exploit was already setup for us by having eip on the stack overwritten with filler bytes “414141”. We can then use a tool called byakugan that, when we give it an offset, tells us which registers we have control of and at what offset.<br><br>

      <img src="images/9.png" alt="9" width="500"><br><br>
      <img src="images/8.png" alt="8" width="600"><br><br>
      <img src="images/10.png" alt="10" width="500"><br><br>

      &emsp;&emsp;We use this offset in the javascript function to make the s variable is the correct size to go right before eip, so that anything we add after will then be guaranteed to overwrite eip. We use 1028 / 2 because MakeString() actually returns two bytes for every on requested. We then concatenate the d-word “\u4242\u4242” to validate that we have done everything correctly with WinDbg.<br><br>

      <img src="images/11.png" alt="11" width="600"><br><br>

      &emsp;&emsp;According to instructor Antoniewicz, we’re now hacking! Next is to change the value we put at esp to the jpm command rather than the filler so that we can have the program run our shellcode without knowing exactly where it is in memory (trampoline method). We cheat a little bit to find the jmp command location as we know where to look already, so we search between address locations for the byte values using “s 54430000 5442b0000 ff e4”.<br><br>

      <img src="images/12.png" alt="12" width="500"><br><br>

      &emsp;&emsp;After adding the location of the jmp command (and learning that we have to swap the byte couples), we learn another “gotcha” in that we must also add an additional four filler bytes for the cleaning of the function arguments off the stack. Now we can concatenate the location of our shellcode and…<br><br>

      <img src="images/13.png" alt="13" width="600"><br><br>

      &emsp;&emsp;Yippee! We trigger the vulnerability, our shellcode gets run, and the calculator gets launched!<br><br>

      &emsp;&emsp;The second class focused on lots of movie references, and also program heaps and more windows debugging. After calling new() to create an object, space on the heap gets allocated using the malloc() system call, but there are other APIs that can get called as well, building upon each other depending on the space needed. In cases of very small allocations (<16KB), a front-end allocator will get called which creates a low fragmentation heap. If more space is needed, a back end allocator will be invoked (16KB - 512KB), and if even more space is needed VirtualAlloc() will be called (>512KB). Internet Explorer uses VirtualAlloc(), which gives us information on how to do heap exploitations through browser applications.<br><br>

      &emsp;&emsp;The particular vulnerability that this class focuses on is called a “use-after-free”, which has been a more common and successful attack recently than attacks using the stack. The basics of exploiting this vulnerability involves four steps. First, we free an object on the heap, and then we replace it with something that we control. After we then trigger the use of that object again, it uses whatever shellcode we’ve placed in the correct location.<br><br>

      &emsp;&emsp;To execute on this, we use a command to enable the page heap on the virtual machine and user mode stack tracing, which gives us more detail in the crash report from Internet Explorer in WinDbg and let’s us see details about the current allocation status, size, and the history of heap allocation calls. This lets us know exactly where space on the heap is getting freed from a delete call. At this point we can then use javascript to write attacker control data to the same location and the same size as the space that was being freed where we were able to crash the browser application. To get our shellcode to run, we take advantage of how the heap allocator/VirtualAlloc() works and make make an allocation for a large amount of data which creates a predictable pattern with the different portions of the heap, letting us know where the heap portions are starting and ending. This ultimately lets us know where to position our shellcode in order to have it ran when the object that we placed in the free space gets used again.<br><br>
    </p>
    <h2 class="textHeader">Week 3</h2>
    <p class="textContent">
      &emsp;&emsp;Defense Against the Dark Arts featured speaker Craig Schmugar this week, who covered malware defense and some of the basics for how people/software identify malware.<br><br>

      &emsp;&emsp;This week’s content began by discussing the attack flow of malware operations, and when the opportunities for defense are. The first step in malware’s attack is called “First Contact”, which can be through avenues such as email, malvertising, or a watering hole (a frequently visited location by a target). Once the malware is in, it can begin local execution, but needs to go undiscovered to be ultimately successful. The amount of malware that is signed binary is increasing exponentially with 16 million malicious signed binaries in 2014, so this has become one popular way that malware has been able to hide themselves as legitimate. They can also change the time stamps of the files they create or modify, and they can use filenames that look very similar to OS filenames. Once a malware is on its target and running, it then harvests the information it is looking for such as emails, browser data, screen scrapes, and passwords and sends this data back through web or email.<br><br>

      &emsp;&emsp;The first tool we looked at this week was Yara. Yara is a tool that matches signatures within file binaries to identify them malicious. This is part of what AV providers use to identify malicious content on their users’ machines. The skill in writing these yara rules is making them as concise as possible in order to keep download/update sizes small for users while also providing enough information to not provide any false positives. The key is balance, and the best rules will be short and never incorrectly identify because they match for patterns that are completely unique to the specific malware or type of malware.<br><br>

      &emsp;&emsp;In class we used Yara and were prompted to find signatures that correctly matched two pieces of malware that we were provided. For the first one, I was able to find the string “Jenna Jam” on my own that identified the malware, and we were then given the complete answer which also included the string “AikaQ”.<br><br>

      <img src="images/1.png" alt="1" width="600"><br><br>

      &emsp;&emsp;One the second one, again I was able to identify the first string match of “DownloaderActiveX”; however, there was also another one which was a CLSID “c1b7e532-3ecb-4e9e-bb3a-2951ffe71c61”, but the complete answer did this with a binary pattern and jumps (the bracket notation).<br><br>

      <img src="images/2.png" alt="2" width="600"><br><br>

      &emsp;&emsp;The second lab we did this week was on day two and covered a tool called “Cuckoo”. Cuckoo analyzes the running of a process, and can behavior such as api calls by spawned processes; files being created, downloaded, or deleted; memory dumps; and network traffic. Cuckoo claims to be able to provide analysis on any type of file. In the lab we ran Cuckoo on the malware that we originally analyzed in week one. In conjunction with FakeNet, Cuckoo showed us the malware trying to download files such as “tongji2.exe” and creating a file called “svchest.exe” (rather than “svchost.exe”).<br><br>

      &emsp;&emsp;The wrap-up for this week included a discussion around the role of automation within identifying malware. Around 99% of signature creation is automated now; however, Craig Schmugar emphasized that the remaining 1% must still be done by hand because the work by a human is still far superior. While the work in signature recognition has largely been covered by automation, there is still human work to be done and new progress to be made such as in the field of AI with malware detection.<br><br>

      <h3>Blog Post:</h3>

      NEWLY FOUND KEYLOGGER MALWARE AND HOW TO IDENTIFY IT<br>
      Posted by: Ryder McDowell<br><br>

      A new piece of malware has been identified at McDowell Anti-Malware Labs that could potentially breach the security of your passwords or other sensitive information.<br><br>

      After file examination, we have identified Yara signatures that uniquely identify this malware and help diagnose whether you have been infected. The signatures to match for are “GetTuPian.asp”, “tsapcmp”, and “Keyboard”, and the full Yara rule can be seen in the following figure (A).<br><br>

      <img src="images/3.png" alt="A" width="600"><br>
      (A)
      <br><br>

      After analyzing the behavior of this piece of malware with the tool Cuckoo, we are fairly certain that the malware is some sort of a keylogger because of the frequent references that are seen in the malware activity to files that relate to the keyboard and its drivers. Some of these targeted files include “wm.ime” (windows input method editor), system keyboard layouts, input hotkeys, and "kbdus.dll" (US keyboard functions). Some of this activity can be seen in the following figures (B, C) of logs from Cuckoo.<br><br>

      <img src="images/4.png" alt="B" width="800"><br>
      (B)
      <br><br>
      <img src="images/5.png" alt="C" width="800"><br>
      (C)
      <br><br>

      If you have recognized any of this behavior on your computer, you have most likely been infected by this malware and should immediately stop any actions that involve sensitive information until the malware removed.<br><br>
    </p>
    <h2 class="textHeader">Week 2</h2>
    <p class="textContent">
      &emsp;&emsp;This week’s content in Defense Against the Dark Arts covered malware forensics and the methods and tools involved with it. Two in-class labs were focused on this week as well that aimed to provide experience with the forensic tools FTK Imager and Volatility.<br><br>

      &emsp;&emsp;The basis of malware forensics is to identify, preserve, and analyze evidence, and then present the results and findings to a law official for further judgment. An important aspect of being involved in malware forensics is to stay professional, unbiased, and respect your role as just a reporter of evidence, leaving the interpretation and ultimate decision on how to move forward to the court of law. Some of the important evidence acquisitions are memory, drive or long-term storage, and any network traffic.<br><br>

      &emsp;&emsp;Because evidence is everything in forensics, there are specific precautions and procedures to follow when executing an investigation, many of which have already been predefined. One of these procedures revolves around the order of volatility within a computer system, and describes the order in which evidence should be collected from a system in order to ensure the most results. The order begins with system memory and temporary file systems such as as the swap file or paging file, and ends with any physical configurations or backups. It is also extremely important to reduce any contamination of potential evidence in the process gathering it.<br><br>

      &emsp;&emsp;The first in-class lab of focus this week was a lab on the FTK Imager tool. This tool allows you to create forensic images of a drive or other source of storage, and export them to any destination, such as an external drive plugged into the target. This tool allows you to copy data off of the storage such as the master file table, page table file, hibernation file, and any other content on the drive. It can also export the data to different formats, included just raw. In the lab, we tested the tool by just creating an image of our virtual machine in order to play around with the different features and capabilities.<br><br>

      &emsp;&emsp;The second lab we did in-class demonstrated the Volatility tool. This is a command line tool that is used to perform analysis on memory dumps and can provide a lot of information on what was stored in memory, such as information on the operating system, networking artifacts, process permissions, and what processes currently loaded in memory. A command that was covered in class was “dlllist”, which lists all of the currently loaded processes and their id’s, but also the processes’ loaded dll’s to see which are related.<br><br>
    </p>
    <h2 class="textHeader">Week 1</h2>
    <p class="textContent">
      &emsp;&emsp;To begin defending against dark arts, we must first be able to identify them. This week’s content of CS 373 included some of the basics of malware, such as being able to identify different types of malware, analyzing their behavior in order to prevent future attacks, and who these attackers even are.<br /><br />

      &emsp;&emsp;In the world of malware and malware defense, there are many descriptive terms that are used in order to communicate with each other professionally. Two very commonly used terms are white and black, which are used to describe if a piece of software is clean or dirty, respectively. This allows communities involved to be aware if certain software can be trusted. When the integrity of a sample is unknown, it is referred to as grey. Another basic for malware is the naming convention. The convention is as follows: type(:), platform(/), family, (.)variant, and (!)information. An example of this looks like: “Trojan:Win32/Reveton.N”.<br /><br />

      &emsp;&emsp;A term that was new to me that ended up receiving some discussion in the lecture was a “polymorphic” piece of malware. This is a type of malware that will constantly change key elements of itself to avoid detection and make stopping it much harder. What was most interesting about polymorphic malware though, was its rarity. The lecturer, Christiaan Beek with Intel Security/McAfee Labs, stated that these pieces of malware were extremely hard to detect and diagnose, yet they were not extremely difficult to create. I believe that the reasoning for this was that they are not worth the extra effort/skill for a hacker to create when there are much simpler alternatives that can be just as successful. What’s particularly unsettling about this is that these threats are still not having to use the most powerful tricks, and can still be a massive problem.<br /><br />

      &emsp;&emsp;Just like attackers have tools for creating malware, we also have tools for analyzing them. Each tool has a purpose, and they can do things such as monitor process events and network activity, close off connections, or even create fake connections in order to capture any outgoing requests. Some names of tools for analyzing malware include: Process Monitor, FakeNet, FileInsight, and Wireshark. The malware needs to be running in order to be able to analyze it though, so it is important to create simulated environments to run the malware in order to keep it contained and analyze safely. These are sometimes called “goats”, a sacrificial environment to let the malware do what it does.<br /><br />

      &emsp;&emsp;So who really are these attackers? And what do they want? We classify malware attackers as APTs, or Advanced Persistent Threats, and they mostly consist of governments, organized crime groups, and competitors within a marketplace. One of their biggest motivators, unsurprisingly, is often money, but it can also be for ideology, revenge, or just for the fun. A typical pattern is also followed by these attackers. This pattern includes reconnaissance, weaponization, delivery, exploitation, installation, command and control, and finally, action.<br /><br />

      &emsp;&emsp;What really drove home for me why malware defense and forensics and be so exciting, is the concept of baiting. Just like fishing, the excitement comes from knowing the targets and strategically setting up environments to get the best of them. Two forms of baiting were mentioned: honeypot baiting and baiting for malware replication. Honeypots are machines that are placed around the world waiting to receive a malware attack in order for it to be analyzed, and baiting for malware replication involves intentionally staging an environment that a piece of malware is being tested in to force certain behaviors (if those behaviors exist).<br /><br />
    </p>
  </div>
</body>

</html>
